# -*- coding: utf-8 -*-
"""lstm-rnn.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1lD0Tbvm4hIqO6BcmHch5HrsssgW9CJTB
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

from google.colab import files
uploaded = files.upload()
import io
df = pd.read_csv(io.BytesIO(uploaded['washington-flipped.csv']),index_col='date',parse_dates=True)

df.head()

df.plot(figsize=(12,6))

len(df)

train = df.iloc[280:len(df)-65] #279-280 for Training and 180 for Prediction
test = df.iloc[len(df)-65:len(df)-58]

from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()

scaler.fit(train)
scaled_train = scaler.transform(train)
scaled_test = scaler.transform(test)

scaled_train[:10]

from keras.preprocessing.sequence import TimeseriesGenerator

# define generator
n_input = 2
n_features = 1
generator = TimeseriesGenerator(scaled_train, scaled_train, length=n_input, batch_size=1)

X,y = generator[0]
print(f'Given the Array: \n{X.flatten()}')
print(f'Predict this y: \n {y}')

X.shape

n_input = 1
generator = TimeseriesGenerator(scaled_train, scaled_train, length=n_input, batch_size=1)

from keras.models import Sequential
from keras.layers import Dense
from keras.layers import LSTM

model = Sequential()
model.add(LSTM(100, activation='relu', input_shape=(n_input, n_features)))
model.add(Dense(1))
model.compile(optimizer='adam', loss='mse')

model.summary()

model.fit(generator,epochs=10)

loss_per_epoch = model.history.history['loss']
plt.plot(range(len(loss_per_epoch)),loss_per_epoch)

last_train_batch = scaled_train[-1:]
last_train_batch = last_train_batch.reshape((1, n_input, n_features))

model.predict(last_train_batch)

scaled_test[0]

test_predictions = []

first_eval_batch = scaled_train[-n_input:]
current_batch = first_eval_batch.reshape((1, n_input, n_features))

for i in range(len(test)):
    
    # get the prediction value for the first batch
    current_pred = model.predict(current_batch)[0]
    
    # append the prediction into the array
    test_predictions.append(current_pred) 
    
    # use the prediction to update the batch and remove the first value
    current_batch = np.append(current_batch[:,1:,:],[[current_pred]],axis=1)

test_predictions

test.head()

true_predictions = scaler.inverse_transform(test_predictions)
print(true_predictions)
# plt.figure(figsize=[14, 7]);
# plt.title('LSTM Recurrent Neural Network: California COVID-19 Total Cases Prediction: With Vaccines')
# plt.ylabel('Number of COVID-19 Cases in Millions')
# plt.xlabel('Days after March 7th')
# plt.plot(true_predictions)
test['Predictions'] = true_predictions
test.plot(figsize=(14,5))

from sklearn.metrics import mean_squared_error
from sklearn.metrics import r2_score
from math import sqrt
rmse=sqrt(mean_squared_error(test['positive'],test['Predictions']))
print(rmse)
print(r2_score(test['positive'], test['Predictions']))